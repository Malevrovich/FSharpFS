# FSFS - FSharp FileSystem

`Скрябин Иван P34092 335146`

## Возможности
- FSFS в качестве постоянного хранилища данных и метаданных использует один файл/блочное устройство
- Внутри имеется кэш метаданных, представляющий из себя дерево файлов и каталог. Кэш данных отсутствует(однако в каком-то виде предоставлен ядром)
- По умолчанию всем файлам и каталогам владельцем устанавливается root, однако он при желании может это изменить при помощи `chown`. Управление доступом на уровне файловой системы не реализовано, она лишь хранит текущую маску(которую можно изменить при помощи `chmod`), проверкой наличия прав занимается ядро.
- FSFS позволяет создавать файлы и каталоги, со стандартным ограничением: длина имени не больше 255 символов.
- FSFS позволяет изменять размер, читать и записывать данные в файлы
- FSFS допускает многопоточный доступ. При возникновении конфликтов система остается в валидном состоянии(либо один из запросов выполняется, второй отклоняется, либо оба отклоняются)
- Операции над файловой системой реализованы таким образом, что при возникновении ошибок, они откатывают изменения и система остается в валидном состоянии.
- При непредвиденном отключении FSFS остается всегда в валидном состоянии

## Пример работы

Создание директорий

<img src="https://github.com/user-attachments/assets/a7af5ac3-8ce2-47fa-888f-41632d2c4097" width=50% height=50%>

Запись и чтение файлов

<img src="https://github.com/user-attachments/assets/3c48e028-3baa-4169-b54b-235b59c137db" width=50% height=50%>


[Здесь](https://github.com/Malevrovich/FSharpFS/tree/main/tests/scripts) находятся скрипты, для тестирования

Один из тестовых сценариев. FSFS монтируется в /tmp/fsfs
```bash
dd if=/dev/random of=/tmp/fsfs_test_data bs=4096 count=100

dd if=/tmp/fsfs_test_data of=/tmp/fsfs/small bs=1 count=1
dd if=/tmp/fsfs_test_data of=/tmp/fsfs/small bs=1 count=10
dd if=/tmp/fsfs_test_data of=/tmp/fsfs/small bs=1 count=100
dd if=/tmp/fsfs_test_data of=/tmp/fsfs/small bs=1 count=1000

dd if=/tmp/fsfs_test_data of=/tmp/fsfs_test_cut bs=1 count=1000
cmp /tmp/fsfs/small /tmp/fsfs_test_cut
```
![image](https://github.com/user-attachments/assets/a4b187fe-f18f-4853-8176-12b10717a7e7)

## Как это работает
### Структура файла
Весь файл(блочное устройство) делится на 3 зоны:
1. Метаданные. Зона разбивается на равные по размеру блоки, в каждом блоке хранится одна из записей - метаданные файла, метаданные директории или расширение метаданных файла(поскольку список блоков данных может быть довольно длинным)
```F#
type MetadataDTOBlock =
    | FileDTO of FileMetadataDTO
    | FileExtensionDTO of FileMetadataExtensionDTO
    | DirectoryDTO of DirectoryMetadataDTO
```
2. Строки. Зона разбивается на блоки по 255 байт, в каждом блоке хранится название файла/директории(без пути)
3. Данные. Зона разбивается на блоки по 4096 байт, они предназначены для хранения данных записываемых в файл. Структура метаданных устроена так, что каждый файл ссылается на родительскую директорию, соответственно нет нужды в отдельных блоках хранящих данные о файлах в директории.

### BitmapAllocator
BitmapAllocator - сердце этого проекта. Он используется почти везде.
В частности менеджментом блоков в каждой зоне занимается BitmapAllocator(по одному на каждую зону).

По названию можно догадаться, что это аллокатор, который базируется на битовой маске, в которой 1 означает занятый блок, а 0 - свободный.
В оперативной памяти он представлен классом [BitmapAllocator](https://github.com/Malevrovich/FSharpFS/blob/main/src/FSharpFS/BitmapAllocator.fs#L77), который владеет изменяемым массивом uint64. Аллокатор допускает многопоточный доступ и реализован по принципу lock-free при помощи атомарных операций. Для ускорения работы используются особые битовые операции: поиск первого ненулевого бита и количество ненулевых бит(обе операции на большинстве процессоров представлены одной инструкцией)

BitmapAllocator помимо того, что управляет блоками в зонах, используется в реализации [ObjectPool](https://github.com/Malevrovich/FSharpFS/blob/main/src/FSharpFS/ObjectPool.fs), при помощи которого, в свою очередь, реализован весь многопоточный ввод-вывод(для того, чтобы каждому потоку мог быть предоставлен независимый доступ к файлу)

В файле BitmapAllocator представлен сырым массивом бит. За установку значений отвечает [BitmapAllocatorPersister](https://github.com/Malevrovich/FSharpFS/blob/main/src/FSharpFS/BitmapAllocatorPersistence.fs#L12)
